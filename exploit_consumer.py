import asyncio
import nats
from scapy.all import Ether
from scapy.compat import raw
from datetime import datetime
import os
import sys
import platform
import threading
import time

subject = "exfiltration.traffic"  
stream = "exfiltration_stream"   

async def main():
    
    msg_counter = 0
    total_messages = 0
    last_report_time = datetime.now()
    last_sound_time = datetime.now()
    
   
    MILESTONE = 250  
    MIN_SOUND_INTERVAL = 0.2  
    
    
    def play_sound_nonblocking():
        def sound_thread_func():
            if platform.system() == "Darwin": 
               
                os.system('afplay /System/Library/Sounds/Sosumi.aiff &')
            elif platform.system() == "Windows":
                import winsound
                
                threading.Thread(target=lambda: winsound.Beep(2000, 200)).start()
            else:  
                print('\a\a\a', end='', flush=True)  
        
       
        threading.Thread(target=sound_thread_func).start()
    
    
    async def report_activity():
        nonlocal last_report_time, msg_counter
        
        while True:
            await asyncio.sleep(60) 
            
            now = datetime.now()
            time_diff = (now - last_report_time).total_seconds() / 60.0 
            
            if time_diff > 0:
                
                msg_rate = int(msg_counter / time_diff)
                
                
                timestamp = now.strftime("%Y-%m-%d %H:%M:%S")
                print(f"[{timestamp}] [EXFILTRATION STATS] Rate: {msg_rate} msgs/min | Total: {total_messages} messages")
                
                
                msg_counter = 0
                last_report_time = now
    
    async def message_handler(msg):
        nonlocal msg_counter, total_messages, last_sound_time
        pkt_data = msg.data
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        try:
            pkt = Ether(pkt_data)
            print(f"[{timestamp}] [EXFILTRATION] Detected data exfiltration: {pkt.summary()}")
            
            
            msg_counter += 1
            total_messages += 1
            
            
            if total_messages % MILESTONE == 0:
                play_sound_nonblocking()
                print(f"[{timestamp}] [EXFILTRATION MILESTONE] Processed {total_messages} total exfiltration messages")
            else:
                
                current_time = datetime.now()
                time_since_last_sound = (current_time - last_sound_time).total_seconds()
                
                
                current_rate = msg_counter / max(0.1, (current_time - last_report_time).total_seconds())
                
                
                sound_interval = max(MIN_SOUND_INTERVAL, 2.0 / max(1, current_rate)) 
                
                if time_since_last_sound >= sound_interval:
                    play_sound_nonblocking()
                    last_sound_time = current_time
                
        except Exception as e:
            print(f"[{timestamp}] [EXFILTRATION ERROR] Could not decode packet: {e}")

    
    nc = await nats.connect("nats://localhost:4222")
    js = nc.jetstream()
    
    
    try:
        
        stream_info = await js.stream_info(stream)
        print(f"Connected to existing stream: {stream}")
    except Exception:
        
        try:
            await js.add_stream(name=stream, subjects=[subject])
            print(f"Created new stream: {stream}")
        except Exception as e:
            print(f"Error creating stream: {e}")
            return

    
    await js.subscribe(subject, cb=message_handler, durable="exfiltration_monitor")

    print("Exfiltration consumer is listening for data exfiltration packets...")
    print("Sound frequency adapts to message rate - faster traffic = more frequent sounds")
    print(f"A special sound alert also plays every {MILESTONE} messages")
    print("WARNING: Data exfiltration alerts are high priority and should be investigated immediately!")
    
    
    report_task = asyncio.create_task(report_activity())
    
    
    try:
       
        pending = asyncio.Future()
        await pending
    except asyncio.CancelledError:
       
        report_task.cancel()
        try:
            await report_task
        except asyncio.CancelledError:
            pass

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Exfiltration consumer interrupted.")
        